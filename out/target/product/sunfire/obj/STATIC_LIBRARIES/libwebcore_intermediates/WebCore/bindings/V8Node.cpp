/*
    This file is part of the WebKit open source project.
    This file has been generated by generate-bindings.pl. DO NOT MODIFY!

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Library General Public
    License as published by the Free Software Foundation; either
    version 2 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Library General Public License for more details.

    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
    Boston, MA 02111-1307, USA.
*/
#include "config.h"
#include "RuntimeEnabledFeatures.h"
#include "V8Proxy.h"
#include "V8Binding.h"
#include "V8BindingState.h"
#include "V8DOMWrapper.h"
#include "V8IsolatedContext.h"

#undef LOG

#include "ExceptionCode.h"
#include "V8Document.h"
#include "V8Element.h"
#include "V8Event.h"
#include "V8NamedNodeMap.h"
#include "V8Node.h"
#include "V8NodeList.h"
#include "wtf/GetPtr.h"
#include "wtf/RefCounted.h"
#include "wtf/RefPtr.h"

namespace WebCore {
namespace NodeInternal {

template <typename T> void V8_USE(T) { }

  static v8::Handle<v8::Value> nodeNameAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.nodeName._get");
    Node* imp = V8Node::toNative(info.Holder());
    return v8StringOrNull(imp->nodeName());
  }

  static v8::Handle<v8::Value> nodeValueAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.nodeValue._get");
    Node* imp = V8Node::toNative(info.Holder());
    return v8StringOrNull(imp->nodeValue());
  }

  static void nodeValueAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.nodeValue._set");
    Node* imp = V8Node::toNative(info.Holder());
    V8Parameter<WithNullCheck> v = value;
    ExceptionCode ec = 0;
    imp->setNodeValue(v, ec);
    if (UNLIKELY(ec))
        V8Proxy::setDOMException(ec);
    return;
  }

  static v8::Handle<v8::Value> nodeTypeAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.nodeType._get");
    Node* imp = V8Node::toNative(info.Holder());
    return v8::Integer::New(imp->nodeType());
  }

  static v8::Handle<v8::Value> parentNodeAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.parentNode._get");
    Node* imp = V8Node::toNative(info.Holder());
    return toV8(imp->parentNode());
  }

  static v8::Handle<v8::Value> childNodesAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.childNodes._get");
    Node* imp = V8Node::toNative(info.Holder());
    return toV8(imp->childNodes());
  }

  static v8::Handle<v8::Value> firstChildAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.firstChild._get");
    Node* imp = V8Node::toNative(info.Holder());
    return toV8(imp->firstChild());
  }

  static v8::Handle<v8::Value> lastChildAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.lastChild._get");
    Node* imp = V8Node::toNative(info.Holder());
    return toV8(imp->lastChild());
  }

  static v8::Handle<v8::Value> previousSiblingAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.previousSibling._get");
    Node* imp = V8Node::toNative(info.Holder());
    return toV8(imp->previousSibling());
  }

  static v8::Handle<v8::Value> nextSiblingAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.nextSibling._get");
    Node* imp = V8Node::toNative(info.Holder());
    return toV8(imp->nextSibling());
  }

  static v8::Handle<v8::Value> attributesAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.attributes._get");
    Node* imp = V8Node::toNative(info.Holder());
    return toV8(imp->attributes());
  }

  static v8::Handle<v8::Value> ownerDocumentAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.ownerDocument._get");
    Node* imp = V8Node::toNative(info.Holder());
    return toV8(imp->ownerDocument());
  }

  static v8::Handle<v8::Value> namespaceURIAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.namespaceURI._get");
    Node* imp = V8Node::toNative(info.Holder());
    return v8StringOrNull(imp->namespaceURI());
  }

  static v8::Handle<v8::Value> prefixAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.prefix._get");
    Node* imp = V8Node::toNative(info.Holder());
    return v8StringOrNull(imp->prefix());
  }

  static void prefixAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.prefix._set");
    Node* imp = V8Node::toNative(info.Holder());
    V8Parameter<WithNullCheck> v = value;
    ExceptionCode ec = 0;
    imp->setPrefix(v, ec);
    if (UNLIKELY(ec))
        V8Proxy::setDOMException(ec);
    return;
  }

  static v8::Handle<v8::Value> localNameAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.localName._get");
    Node* imp = V8Node::toNative(info.Holder());
    return v8StringOrNull(imp->localName());
  }

  static v8::Handle<v8::Value> baseURIAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.baseURI._get");
    Node* imp = V8Node::toNative(info.Holder());
    return v8StringOrNull(imp->baseURI());
  }

  static v8::Handle<v8::Value> textContentAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.textContent._get");
    Node* imp = V8Node::toNative(info.Holder());
    return v8StringOrNull(imp->textContent());
  }

  static void textContentAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.textContent._set");
    Node* imp = V8Node::toNative(info.Holder());
    V8Parameter<WithNullCheck> v = value;
    ExceptionCode ec = 0;
    imp->setTextContent(v, ec);
    if (UNLIKELY(ec))
        V8Proxy::setDOMException(ec);
    return;
  }

  static v8::Handle<v8::Value> parentElementAttrGetter(v8::Local<v8::String> name, const v8::AccessorInfo& info) {
    INC_STATS("DOM.Node.parentElement._get");
    Node* imp = V8Node::toNative(info.Holder());
    return toV8(imp->parentElement());
  }

  static v8::Handle<v8::Value> hasChildNodesCallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.hasChildNodes");
    Node* imp = V8Node::toNative(args.Holder());
    return v8Boolean(imp->hasChildNodes());
  }

  static v8::Handle<v8::Value> cloneNodeCallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.cloneNode");
    Node* imp = V8Node::toNative(args.Holder());
    bool deep = args[0]->BooleanValue();
    return toV8(imp->cloneNode(deep));
  }

  static v8::Handle<v8::Value> normalizeCallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.normalize");
    Node* imp = V8Node::toNative(args.Holder());
    imp->normalize();
    return v8::Handle<v8::Value>();
  }

  static v8::Handle<v8::Value> isSupportedCallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.isSupported");
    Node* imp = V8Node::toNative(args.Holder());
    V8Parameter<> feature = args[0];
    V8Parameter<WithNullCheck> version = args[1];
    return v8Boolean(imp->isSupported(feature, version));
  }

  static v8::Handle<v8::Value> hasAttributesCallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.hasAttributes");
    Node* imp = V8Node::toNative(args.Holder());
    return v8Boolean(imp->hasAttributes());
  }

  static v8::Handle<v8::Value> isSameNodeCallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.isSameNode");
    Node* imp = V8Node::toNative(args.Holder());
    Node* other = V8Node::HasInstance(args[0]) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;
    return v8Boolean(imp->isSameNode(other));
  }

  static v8::Handle<v8::Value> isEqualNodeCallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.isEqualNode");
    Node* imp = V8Node::toNative(args.Holder());
    Node* other = V8Node::HasInstance(args[0]) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;
    return v8Boolean(imp->isEqualNode(other));
  }

  static v8::Handle<v8::Value> lookupPrefixCallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.lookupPrefix");
    Node* imp = V8Node::toNative(args.Holder());
    V8Parameter<WithNullCheck> namespaceURI = args[0];
    return v8StringOrNull(imp->lookupPrefix(namespaceURI));
  }

  static v8::Handle<v8::Value> isDefaultNamespaceCallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.isDefaultNamespace");
    Node* imp = V8Node::toNative(args.Holder());
    V8Parameter<WithNullCheck> namespaceURI = args[0];
    return v8Boolean(imp->isDefaultNamespace(namespaceURI));
  }

  static v8::Handle<v8::Value> lookupNamespaceURICallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.lookupNamespaceURI");
    Node* imp = V8Node::toNative(args.Holder());
    V8Parameter<WithNullCheck> prefix = args[0];
    return v8StringOrNull(imp->lookupNamespaceURI(prefix));
  }

  static v8::Handle<v8::Value> compareDocumentPositionCallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.compareDocumentPosition");
    Node* imp = V8Node::toNative(args.Holder());
    Node* other = V8Node::HasInstance(args[0]) ? V8Node::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;
    return v8::Integer::New(imp->compareDocumentPosition(other));
  }

  static v8::Handle<v8::Value> dispatchEventCallback(const v8::Arguments& args) {
    INC_STATS("DOM.Node.dispatchEvent");
    Node* imp = V8Node::toNative(args.Holder());
    ExceptionCode ec = 0;
    {
    Event* event = V8Event::HasInstance(args[0]) ? V8Event::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;
    bool result = imp->dispatchEvent(event, ec);
    if (UNLIKELY(ec)) goto fail;
    return v8Boolean(result);
    }
  fail:
    V8Proxy::setDOMException(ec);
    return v8::Handle<v8::Value>();
  }

} // namespace NodeInternal

static const BatchedAttribute Node_attrs[] = {
    {
        // Attribute 'nodeName' (Type: 'readonly attribute' ExtAttr: 'ConvertNullStringTo')
        "nodeName",
        NodeInternal::nodeNameAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'nodeValue' (Type: 'attribute' ExtAttr: 'ConvertNullToNullString ConvertNullStringTo')
        "nodeValue",
        NodeInternal::nodeValueAttrGetter,
        NodeInternal::nodeValueAttrSetter,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'nodeType' (Type: 'readonly attribute' ExtAttr: '')
        "nodeType",
        NodeInternal::nodeTypeAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'parentNode' (Type: 'readonly attribute' ExtAttr: '')
        "parentNode",
        NodeInternal::parentNodeAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'childNodes' (Type: 'readonly attribute' ExtAttr: '')
        "childNodes",
        NodeInternal::childNodesAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'firstChild' (Type: 'readonly attribute' ExtAttr: '')
        "firstChild",
        NodeInternal::firstChildAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'lastChild' (Type: 'readonly attribute' ExtAttr: '')
        "lastChild",
        NodeInternal::lastChildAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'previousSibling' (Type: 'readonly attribute' ExtAttr: '')
        "previousSibling",
        NodeInternal::previousSiblingAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'nextSibling' (Type: 'readonly attribute' ExtAttr: '')
        "nextSibling",
        NodeInternal::nextSiblingAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'attributes' (Type: 'readonly attribute' ExtAttr: '')
        "attributes",
        NodeInternal::attributesAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'ownerDocument' (Type: 'readonly attribute' ExtAttr: '')
        "ownerDocument",
        NodeInternal::ownerDocumentAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'namespaceURI' (Type: 'readonly attribute' ExtAttr: 'ConvertNullStringTo')
        "namespaceURI",
        NodeInternal::namespaceURIAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'prefix' (Type: 'attribute' ExtAttr: 'ConvertNullToNullString ConvertNullStringTo')
        "prefix",
        NodeInternal::prefixAttrGetter,
        NodeInternal::prefixAttrSetter,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'localName' (Type: 'readonly attribute' ExtAttr: 'ConvertNullStringTo')
        "localName",
        NodeInternal::localNameAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'baseURI' (Type: 'readonly attribute' ExtAttr: 'ConvertNullStringTo')
        "baseURI",
        NodeInternal::baseURIAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'textContent' (Type: 'attribute' ExtAttr: 'ConvertNullToNullString ConvertNullStringTo')
        "textContent",
        NodeInternal::textContentAttrGetter,
        NodeInternal::textContentAttrSetter,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
    {
        // Attribute 'parentElement' (Type: 'readonly attribute' ExtAttr: '')
        "parentElement",
        NodeInternal::parentElementAttrGetter,
        0,
        V8ClassIndex::INVALID_CLASS_INDEX /* no data */,
        static_cast<v8::AccessControl>(v8::DEFAULT),
        static_cast<v8::PropertyAttribute>(v8::None),
        0 /* on instance */
    },
};
static const BatchedCallback Node_callbacks[] = {
  {"insertBefore", V8Node::insertBeforeCallback},
  {"replaceChild", V8Node::replaceChildCallback},
  {"removeChild", V8Node::removeChildCallback},
  {"appendChild", V8Node::appendChildCallback},
  {"hasChildNodes", NodeInternal::hasChildNodesCallback},
  {"cloneNode", NodeInternal::cloneNodeCallback},
  {"normalize", NodeInternal::normalizeCallback},
  {"isSupported", NodeInternal::isSupportedCallback},
  {"hasAttributes", NodeInternal::hasAttributesCallback},
  {"lookupPrefix", NodeInternal::lookupPrefixCallback},
  {"isDefaultNamespace", NodeInternal::isDefaultNamespaceCallback},
  {"lookupNamespaceURI", NodeInternal::lookupNamespaceURICallback},
  {"addEventListener", V8Node::addEventListenerCallback},
  {"removeEventListener", V8Node::removeEventListenerCallback},
};
static const BatchedConstant Node_consts[] = {
  { "ELEMENT_NODE", static_cast<signed int>(1) },
  { "ATTRIBUTE_NODE", static_cast<signed int>(2) },
  { "TEXT_NODE", static_cast<signed int>(3) },
  { "CDATA_SECTION_NODE", static_cast<signed int>(4) },
  { "ENTITY_REFERENCE_NODE", static_cast<signed int>(5) },
  { "ENTITY_NODE", static_cast<signed int>(6) },
  { "PROCESSING_INSTRUCTION_NODE", static_cast<signed int>(7) },
  { "COMMENT_NODE", static_cast<signed int>(8) },
  { "DOCUMENT_NODE", static_cast<signed int>(9) },
  { "DOCUMENT_TYPE_NODE", static_cast<signed int>(10) },
  { "DOCUMENT_FRAGMENT_NODE", static_cast<signed int>(11) },
  { "NOTATION_NODE", static_cast<signed int>(12) },
  { "DOCUMENT_POSITION_DISCONNECTED", static_cast<signed int>(0x01) },
  { "DOCUMENT_POSITION_PRECEDING", static_cast<signed int>(0x02) },
  { "DOCUMENT_POSITION_FOLLOWING", static_cast<signed int>(0x04) },
  { "DOCUMENT_POSITION_CONTAINS", static_cast<signed int>(0x08) },
  { "DOCUMENT_POSITION_CONTAINED_BY", static_cast<signed int>(0x10) },
  { "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", static_cast<signed int>(0x20) },
};
static v8::Persistent<v8::FunctionTemplate> ConfigureV8NodeTemplate(v8::Persistent<v8::FunctionTemplate> desc) {
  v8::Local<v8::Signature> default_signature = configureTemplate(desc, "Node",
      v8::Persistent<v8::FunctionTemplate>(), V8Node::internalFieldCount,
      Node_attrs, sizeof(Node_attrs)/sizeof(*Node_attrs),
      Node_callbacks, sizeof(Node_callbacks)/sizeof(*Node_callbacks));
  v8::Local<v8::ObjectTemplate> instance = desc->InstanceTemplate();
  v8::Local<v8::ObjectTemplate> proto = desc->PrototypeTemplate();
  

  // Custom Signature 'isSameNode'
  const int isSameNode_argc = 1;
  v8::Handle<v8::FunctionTemplate> isSameNode_argv[isSameNode_argc] = { V8Node::GetRawTemplate() };
  v8::Handle<v8::Signature> isSameNode_signature = v8::Signature::New(desc, isSameNode_argc, isSameNode_argv);
  proto->Set(v8::String::New("isSameNode"), v8::FunctionTemplate::New(NodeInternal::isSameNodeCallback, v8::Handle<v8::Value>(), isSameNode_signature));

  // Custom Signature 'isEqualNode'
  const int isEqualNode_argc = 1;
  v8::Handle<v8::FunctionTemplate> isEqualNode_argv[isEqualNode_argc] = { V8Node::GetRawTemplate() };
  v8::Handle<v8::Signature> isEqualNode_signature = v8::Signature::New(desc, isEqualNode_argc, isEqualNode_argv);
  proto->Set(v8::String::New("isEqualNode"), v8::FunctionTemplate::New(NodeInternal::isEqualNodeCallback, v8::Handle<v8::Value>(), isEqualNode_signature));

  // Custom Signature 'compareDocumentPosition'
  const int compareDocumentPosition_argc = 1;
  v8::Handle<v8::FunctionTemplate> compareDocumentPosition_argv[compareDocumentPosition_argc] = { V8Node::GetRawTemplate() };
  v8::Handle<v8::Signature> compareDocumentPosition_signature = v8::Signature::New(desc, compareDocumentPosition_argc, compareDocumentPosition_argv);
  proto->Set(v8::String::New("compareDocumentPosition"), v8::FunctionTemplate::New(NodeInternal::compareDocumentPositionCallback, v8::Handle<v8::Value>(), compareDocumentPosition_signature));

  // Custom Signature 'dispatchEvent'
  const int dispatchEvent_argc = 1;
  v8::Handle<v8::FunctionTemplate> dispatchEvent_argv[dispatchEvent_argc] = { V8Event::GetRawTemplate() };
  v8::Handle<v8::Signature> dispatchEvent_signature = v8::Signature::New(desc, dispatchEvent_argc, dispatchEvent_argv);
  proto->Set(v8::String::New("dispatchEvent"), v8::FunctionTemplate::New(NodeInternal::dispatchEventCallback, v8::Handle<v8::Value>(), dispatchEvent_signature));
  batchConfigureConstants(desc, proto, Node_consts, sizeof(Node_consts)/sizeof(*Node_consts));

  // Custom toString template
  desc->Set(getToStringName(), getToStringTemplate());
  return desc;
}

v8::Persistent<v8::FunctionTemplate> V8Node::GetRawTemplate() {
  static v8::Persistent<v8::FunctionTemplate> V8Node_raw_cache_ = createRawTemplate();
  return V8Node_raw_cache_;
}

v8::Persistent<v8::FunctionTemplate> V8Node::GetTemplate() {
  static v8::Persistent<v8::FunctionTemplate> V8Node_cache_ = ConfigureV8NodeTemplate(GetRawTemplate());
  return V8Node_cache_;
}

Node* V8Node::toNative(v8::Handle<v8::Object> object) {
  return reinterpret_cast<Node*>(object->GetPointerFromInternalField(v8DOMWrapperObjectIndex));
}

bool V8Node::HasInstance(v8::Handle<v8::Value> value) {
  return GetRawTemplate()->HasInstance(value);
}


v8::Handle<v8::Object> V8Node::wrap(Node* impl, bool forceNewObject) {
  v8::Handle<v8::Object> wrapper;
  V8Proxy* proxy = 0;
  if (impl->document()) {
    proxy = V8Proxy::retrieve(impl->document()->frame());
    if (proxy && static_cast<Node*>(impl->document()) == static_cast<Node*>(impl))
      proxy->windowShell()->initContextIfNeeded();
  }

  if (!forceNewObject) {
  wrapper = V8DOMWrapper::getWrapper(impl);
  if (!wrapper.IsEmpty())
    return wrapper;
  }

  v8::Handle<v8::Context> context;
  if (proxy)
    context = proxy->context();

  // Enter the node's context and create the wrapper in that context.
  if (!context.IsEmpty())
    context->Enter();
  wrapper = V8DOMWrapper::instantiateV8Object(proxy, V8ClassIndex::NODE, impl);
  // Exit the node's context if it was entered.
  if (!context.IsEmpty())
    context->Exit();
  if (wrapper.IsEmpty())
    return wrapper;

  impl->ref();
  getDOMNodeMap().set(impl, v8::Persistent<v8::Object>::New(wrapper));
  return wrapper;
}

v8::Handle<v8::Value> toV8(PassRefPtr<Node > impl, bool forceNewObject) {
  return toV8(impl.get(), forceNewObject);
}
} // namespace WebCore
